---
title: 阻塞, 非阻塞, 同步, 异步
tags: [linux, C++]
categories: [ 阻塞, 非阻塞, 同步, 异步]
---
### 要明白的一些东西
当发起请求的时候, 我们都只是跟系统内核打交道, 也就是说中间只有两个对象: User Process, Kernel.

IO到底发了什么
* Process发起请求
* Process等待, Kernel准备数据(或是处理操作)
* Kernel 拷贝数据给Process
* 完成
<!--more-->
### 阻塞
阻塞：在操作没有完成之前, 不会返回. 相对于线程来说, 线程调用阻塞函数, 在等待函数返回的时候, 线程会被挂起. linux默认情况下所有的IO都是阻塞的

一个典型的流程图

![](https://encrt.com/wp-content/uploads/2016/12/%E9%98%BB%E5%A1%9EIO.jpg)

* 内核准备好数据, 是一个漫长的过程, 它涉及到从IO设备获取数据到内核, 如果IO设备还需要等待用户的数据, 或是各种远程数据, 那么这个时间将无法控制.
* 需要注意的是, 在整个等待过程中, 线程是被挂起的, 也就是说, 这个过程中这条线程将无法处理任何事情.

### 非阻塞式
非阻塞: 不管操作有没有完成, 都返回. 相对于线程来说, 线程调用非阻塞函数, 无论内核是否准备好数据, 都是立即返回的, 如果系统已经准备好数据了, 那么立即得到数据, 如果没有则返回一个WSAEWOULDBLOCK的错误代码.

![](https://encrt.com/wp-content/uploads/2016/12/非阻塞IO.jpg)

* 内核是立即返回的, 无论是否准备好了数据.
* 程序需要通过自己判断, 是否收到数据
* 程序需要通过不断请求的方式, 直到获取结果

### 同步
指两个程序集, 程序1完成了事件A之后, 通知程序2且等程序2完成事件B, 才能继续下面的代码. 同步与阻塞, 非阻塞个人认为是没有任何关系的, 只是一个理论上的概念. 从某种程度上讲, 阻塞与非阻塞都是同步的.

### 异步
指两个程序集, 程序1完成事件A之后, 通知程序2完成事件B, 但无需等待B执行完成, 即可继续下面的代码. 同样异步不应该与阻塞与非阻塞扯上关系, 这个地方程序2完成事件B之后, 可以通过回调, 信号等方式通知程序1.

### 同步IO
linux下默认情况下, IO都是阻塞同步的.

### 异步IO
异步IO是实现高并发的核心, 通过函数回调, 或是信号通知, 获取结果。

![](https://encrt.com/wp-content/uploads/2016/12/异步IO.png)

* 最后获取数据的时候是通过函数回调, 或是信号通知.

### 总结
高并发核心 = IO多路复用 + 异步.
